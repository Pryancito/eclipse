//! Gestor de almacenamiento simplificado para hardware real
//! 
//! Este módulo proporciona una interfaz simplificada para el acceso al almacenamiento
//! sin soporte RAID, enfocado en funcionar en hardware real.

use core::sync::atomic::{AtomicBool, Ordering};
use alloc::vec::Vec;
use alloc::string::String;
use alloc::format;
use alloc::boxed::Box;

use crate::debug::serial_write_str;
use crate::drivers::ata_direct::AtaDirectDriver;
use crate::drivers::ahci::AhciDriver;
use crate::filesystem::fat32::Fat32DeviceInfo;
use crate::filesystem::eclipsefs::{EclipseFSDeviceInfo, EclipseFSWrapper};

/// Tipos de controladores de almacenamiento soportados
#[derive(Debug, Clone, PartialEq)]
pub enum StorageControllerType {
    ATA,
    NVMe,
    AHCI,
    VirtIO,
    IDE,
}

/// Tipos de sectores de almacenamiento
#[derive(Debug, Clone, PartialEq)]
pub enum StorageSectorType {
    FAT32,
    EclipseFS,
    MBR,
    GPT,
}

// Configuración: deshabilitar AHCI en hardware real para evitar cuelgues en MMIO
const AHCI_ENABLED: bool = false;
// Configuración: forzar modo solo-ATA en hardware real (sin escaneo PCI)
const FORCE_ATA_ONLY: bool = true;

// Driver ATA cacheado (evitar re-inicializaciones repetidas)
static mut CACHED_ATA: Option<AtaDirectDriver> = None;

/// Información de un dispositivo PCI
#[derive(Debug, Clone)]
struct PciDeviceInfo {
    vendor_id: u16,
    device_id: u16,
    class_code: u8,
    subclass_code: u8,
    prog_if: u8,
}

/// Información de un dispositivo de almacenamiento
#[derive(Debug, Clone)]
pub struct StorageDeviceInfo {
    pub name: String,
    pub model: String,
    pub serial: String,
    pub firmware: String,
    pub capacity: u64,
    pub block_size: u32,
    pub controller_type: StorageControllerType,
    pub vendor_id: u16,
    pub device_id: u16,
    pub bus: u8,
    pub device: u8,
    pub function: u8,
}

impl StorageDeviceInfo {
    /// Crear nuevo dispositivo de almacenamiento
    pub fn new(name: String, model: String, serial: String, firmware: String, 
               capacity: u64, block_size: u32, controller_type: StorageControllerType,
               vendor_id: u16, device_id: u16, bus: u8, device: u8, function: u8) -> Self {
        Self {
            name,
            model,
            serial,
            firmware,
            capacity,
            block_size,
            controller_type,
            vendor_id,
            device_id,
            bus,
            device,
            function,
        }
    }
}

/// Información de una partición
#[derive(Debug, Clone)]
pub struct PartitionInfo {
    pub name: String, // Nombre de la partición (ej: "/dev/sda1")
    pub device_name: String,
    pub partition_index: u32,
    pub start_lba: u64,
    pub size_lba: u64,
    pub partition_type: u8,
    pub filesystem_type: String,
    pub bootable: bool,
}

/// Gestor de dispositivos de almacenamiento
pub struct StorageManager {
    pub devices: Vec<StorageDeviceInfo>,
    pub partitions: Vec<PartitionInfo>,
    is_ready: AtomicBool,
}

impl StorageManager {
    /// Crear nueva instancia del StorageManager
    pub fn new() -> Self {
        serial_write_str("STORAGE_MANAGER: Inicializando StorageManager simplificado\n");
        
        Self {
            devices: Vec::new(),
            partitions: Vec::new(),
            is_ready: AtomicBool::new(false),
        }
    }

    /// Inicializar el StorageManager
    pub fn initialize(&mut self) -> Result<(), &'static str> {
        serial_write_str("STORAGE_MANAGER: >>> Inicio initialize()\n");
        serial_write_str("STORAGE_MANAGER: Iniciando detección de dispositivos de almacenamiento\n");
        
        // Detectar dispositivos PCI de almacenamiento
        self.detect_storage_devices()?;
        
        // Detectar particiones en cada dispositivo
        serial_write_str("STORAGE_MANAGER: Detección de dispositivos completada, iniciando detección de particiones\n");
        self.detect_partitions()?;
        
        // Marcar como listo
        self.is_ready.store(true, Ordering::SeqCst);
        
        serial_write_str(&format!("STORAGE_MANAGER: Inicialización completa - {} dispositivos, {} particiones\n", 
                                 self.devices.len(), self.partitions.len()));
        serial_write_str("STORAGE_MANAGER: <<< Fin initialize()\n");
        
        Ok(())
    }

    /// Detectar dispositivos de almacenamiento desde PCI
    fn detect_storage_devices(&mut self) -> Result<(), &'static str> {
        serial_write_str("STORAGE_MANAGER: Detectando dispositivos PCI de almacenamiento\n");
        
        if FORCE_ATA_ONLY {
            serial_write_str("STORAGE_MANAGER: FORCE_ATA_ONLY activo - creando /dev/sda (ATA) sin escaneo PCI\n");
            let sata_device = StorageDeviceInfo::new(
                String::from("/dev/sda"),
                String::from("Generic ATA Drive"),
                String::from("ATA-0000"),
                String::from("FW-ATA"),
                1073741824,
                512,
                StorageControllerType::ATA,
                0,
                0,
                0,
                0,
                0,
            );
            self.devices.push(sata_device);
            serial_write_str("STORAGE_MANAGER: Dispositivo /dev/sda (ATA) creado\n");
            return Ok(());
        }
        
        // Detectar dispositivos PCI reales
        self.detect_pci_storage_devices()?;
        
        // Si no se encontraron dispositivos, crear dispositivos de prueba
        if self.devices.is_empty() {
            serial_write_str("STORAGE_MANAGER: No se encontraron dispositivos PCI, usando dispositivos de prueba\n");
            self.create_test_devices();
        }

        Ok(())
    }

    /// Detectar dispositivos PCI reales
    fn detect_pci_storage_devices(&mut self) -> Result<(), &'static str> {
        serial_write_str("STORAGE_MANAGER: Escaneando bus PCI para dispositivos de almacenamiento\n");
        
        // Escanear bus PCI (implementación simplificada)
        for bus in 0..8 {
            for device in 0..32 {
                for function in 0..8 {
                    if let Ok(pci_info) = self.read_pci_config(bus, device, function) {
                        if self.is_storage_controller(&pci_info) {
                            serial_write_str(&format!("STORAGE_MANAGER: Encontrado controlador de almacenamiento en {:02X}:{:02X}.{}\n", 
                                                     bus, device, function));
                            
                            let storage_device = self.create_storage_device_from_pci(pci_info, bus, device, function);
                            self.devices.push(storage_device);
                        }
                    }
                }
            }
        }
        
        serial_write_str(&format!("STORAGE_MANAGER: Detectados {} dispositivos de almacenamiento\n", self.devices.len()));
        Ok(())
    }

    /// Leer configuración PCI
    fn read_pci_config(&self, bus: u8, device: u8, function: u8) -> Result<PciDeviceInfo, &'static str> {
        // TODO: Implementar lectura PCI real
        // Por ahora, simular algunos dispositivos conocidos
        if bus == 0 && device == 1 && function == 1 {
            // Simular Intel SATA Controller
            return Ok(PciDeviceInfo {
                vendor_id: 0x8086,
                device_id: 0x2822,
                class_code: 0x01,
                subclass_code: 0x06,
                prog_if: 0x01,
            });
        }
        
        Err("Dispositivo no encontrado")
    }

    /// Verificar si es un controlador de almacenamiento
    fn is_storage_controller(&self, pci_info: &PciDeviceInfo) -> bool {
        // Clase 0x01 = Mass Storage Controller
        pci_info.class_code == 0x01 && (
            pci_info.subclass_code == 0x01 || // IDE Controller
            pci_info.subclass_code == 0x06 || // SATA Controller
            pci_info.subclass_code == 0x08    // NVMe Controller
        )
    }

    /// Crear dispositivo de almacenamiento desde información PCI
    fn create_storage_device_from_pci(&self, pci_info: PciDeviceInfo, bus: u8, device: u8, function: u8) -> StorageDeviceInfo {
        let controller_type = match pci_info.subclass_code {
            0x01 => StorageControllerType::IDE,
            0x06 => StorageControllerType::AHCI,
            0x08 => StorageControllerType::NVMe,
            _ => StorageControllerType::ATA,
        };

        let device_name = match controller_type {
            StorageControllerType::AHCI => format!("/dev/sd{}", (b'a' + self.devices.len() as u8) as char),
            StorageControllerType::IDE => format!("/dev/hd{}", (b'a' + self.devices.len() as u8) as char),
            _ => format!("/dev/nvme{}", self.devices.len()),
        };

        StorageDeviceInfo::new(
            device_name,
            format!("PCI {:04X}:{:04X}", pci_info.vendor_id, pci_info.device_id),
            format!("PCI-{:02X}:{:02X}.{}", bus, device, function),
            String::from("PCI-FW"),
            1073741824, // 1GB por defecto
            512, // 512 bytes por sector
                        controller_type,
            pci_info.vendor_id,
            pci_info.device_id,
            bus,
            device,
            function,
        )
    }

    /// Crear dispositivos de prueba
    fn create_test_devices(&mut self) {
        serial_write_str("STORAGE_MANAGER: Creando dispositivos de prueba\n");
        
        // Dispositivo SATA de ejemplo
        let sata_device = StorageDeviceInfo::new(
            String::from("/dev/sda"),
            String::from("Test SATA Drive"),
            String::from("SATA-12345"),
            String::from("FW-1.0"),
            1073741824, // 1GB
            512, // 512 bytes por sector
            StorageControllerType::ATA,
            0x8086,
            0x2822,
            0,
            1,
            1,
        );
        
        self.devices.push(sata_device);
        
        serial_write_str(&format!("STORAGE_MANAGER: Creado dispositivo: {}\n", self.devices[0].name));
    }

    /// Detectar particiones en todos los dispositivos
    fn detect_partitions(&mut self) -> Result<(), &'static str> {
        serial_write_str("STORAGE_MANAGER: Detectando particiones\n");
        
        let device_names: Vec<String> = self.devices.iter().map(|d| d.name.clone()).collect();
        
        for device_name in device_names {
            serial_write_str(&format!("STORAGE_MANAGER: Analizando particiones en {}\n", device_name));
            
            // Clonar el dispositivo para evitar problemas de borrow
            let device = self.devices.iter().find(|d| d.name == device_name).cloned();
            
            if let Some(device) = device {
                // Intentar detectar GPT primero
                if let Ok(partitions) = self.detect_gpt_partitions(&device) {
                    serial_write_str(&format!("STORAGE_MANAGER: Encontradas {} particiones GPT en {}\n", partitions.len(), device_name));
                    self.partitions.extend(partitions);
                } else if let Ok(partitions) = self.detect_mbr_partitions(&device) {
                    serial_write_str(&format!("STORAGE_MANAGER: Encontradas {} particiones MBR en {}\n", partitions.len(), device_name));
                    self.partitions.extend(partitions);
        } else {
                    serial_write_str(&format!("STORAGE_MANAGER: No se encontraron particiones en {}, usando particiones de prueba\n", device_name));
                    self.create_test_partitions(&device);
                }
            }
        }
        
        Ok(())
    }

    /// Detectar particiones GPT
    fn detect_gpt_partitions(&self, device: &StorageDeviceInfo) -> Result<Vec<PartitionInfo>, &'static str> {
        let mut buffer = [0u8; 512];
        let mut partitions = Vec::new();
        
        // Leer GPT Header (sector 1)
        self.read_device_sector(&device.name, 1, &mut buffer)?;
        
        // Verificar firma GPT
        if &buffer[0..8] != b"EFI PART" {
            return Err("No es una tabla GPT válida");
        }
        
        serial_write_str(&format!("STORAGE_MANAGER: GPT válido encontrado en {}\n", device.name));
        
        // Leer tabla de particiones (sector 2)
        self.read_device_sector(&device.name, 2, &mut buffer)?;
        
        // Procesar entradas de particiones GPT (hasta 4 entradas por sector)
        for i in 0..4 {
            let offset = i * 128; // Cada entrada GPT es de 128 bytes
            if offset + 128 > buffer.len() {
                break;
            }
            
            let partition_entry = &buffer[offset..offset + 128];
            
            // Verificar si la entrada está vacía (GUID de tipo todo ceros)
            if partition_entry[0..16].iter().all(|&b| b == 0) {
                continue;
            }
            
            // Leer información de la partición
            let start_lba = u64::from_le_bytes([
                partition_entry[32], partition_entry[33], partition_entry[34], partition_entry[35],
                partition_entry[36], partition_entry[37], partition_entry[38], partition_entry[39],
            ]);
            
            let end_lba = u64::from_le_bytes([
                partition_entry[40], partition_entry[41], partition_entry[42], partition_entry[43],
                partition_entry[44], partition_entry[45], partition_entry[46], partition_entry[47],
            ]);
            
            if start_lba == 0 || end_lba == 0 {
                continue;
            }
            
            let size_lba = end_lba - start_lba + 1;
            let partition_type = self.get_gpt_partition_type(&partition_entry[0..16]);
            let filesystem_type = self.detect_filesystem_type(device, start_lba)?;
            let fs_type_display = filesystem_type.clone();
            
            let partition = PartitionInfo {
                name: format!("{}{}", device.name, partitions.len() + 1),
                device_name: device.name.clone(),
                partition_index: partitions.len() as u32 + 1,
                start_lba,
                size_lba,
                partition_type: 0x00, // GPT no usa partition_type como MBR
                filesystem_type,
                bootable: false, // GPT no usa flag bootable como MBR
            };
            
            partitions.push(partition);
            serial_write_str(&format!("STORAGE_MANAGER: Partición GPT {}: {} ({} sectores)\n", 
                                     partitions.len(), fs_type_display, size_lba));
        }
        
        Ok(partitions)
    }

    /// Detectar particiones MBR
    fn detect_mbr_partitions(&self, device: &StorageDeviceInfo) -> Result<Vec<PartitionInfo>, &'static str> {
        let mut buffer = [0u8; 512];
        let mut partitions = Vec::new();
        
        // Leer MBR (sector 0)
        self.read_device_sector(&device.name, 0, &mut buffer)?;
        
        // Verificar firma de arranque MBR
        if buffer[510] != 0x55 || buffer[511] != 0xAA {
            return Err("No es una tabla MBR válida");
        }
        
        serial_write_str(&format!("STORAGE_MANAGER: MBR válido encontrado en {}\n", device.name));
        
        // Procesar 4 entradas de partición MBR
        for i in 0..4 {
            let offset = 446 + (i * 16); // Cada entrada MBR es de 16 bytes
            let partition_entry = &buffer[offset..offset + 16];
            
            // Verificar si la partición está activa (tipo != 0)
            let partition_type = partition_entry[4];
            if partition_type == 0x00 {
                continue;
            }
            
            // Leer información de la partición
            let start_lba = u32::from_le_bytes([
                partition_entry[8], partition_entry[9], partition_entry[10], partition_entry[11],
            ]) as u64;
            
            let size_lba = u32::from_le_bytes([
                partition_entry[12], partition_entry[13], partition_entry[14], partition_entry[15],
            ]) as u64;
            
            if start_lba == 0 || size_lba == 0 {
                continue;
            }
            
            let bootable = partition_entry[0] == 0x80;
            let filesystem_type = self.detect_filesystem_type(device, start_lba)?;
            let fs_type_display = filesystem_type.clone();
            
            let partition = PartitionInfo {
                name: format!("{}{}", device.name, i + 1),
                device_name: device.name.clone(),
                partition_index: i as u32 + 1,
                start_lba,
                size_lba,
                partition_type,
                filesystem_type,
                bootable,
            };
            
            partitions.push(partition);
            serial_write_str(&format!("STORAGE_MANAGER: Partición MBR {}: {} ({} sectores, {})\n", 
                                     i + 1, fs_type_display, size_lba, if bootable { "bootable" } else { "no bootable" }));
        }
        
        Ok(partitions)
    }

    /// Obtener tipo de partición GPT
    fn get_gpt_partition_type(&self, guid: &[u8]) -> u8 {
        // GUIDs comunes para tipos de partición
        match guid {
            // FAT32
            [0x28, 0x73, 0x2A, 0xC1, 0x1F, 0xF8, 0xD2, 0x11, 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B] => 0x0C,
            // Linux Filesystem
            [0x0F, 0xE8, 0x8C, 0x0F, 0x83, 0x84, 0x72, 0x47, 0x8E, 0x79, 0x3D, 0x69, 0xD8, 0x47, 0x7D, 0xE4] => 0x83,
            // EclipseFS (personalizado)
            [0xAF, 0x3D, 0xC6, 0x0F, 0x83, 0x84, 0x72, 0x47, 0x8E, 0x79, 0x3D, 0x69, 0xD8, 0x47, 0x7D, 0xE4] => 0xAF,
            _ => 0x00,
        }
    }

    /// Detectar tipo de sistema de archivos
    fn detect_filesystem_type(&self, device: &StorageDeviceInfo, start_lba: u64) -> Result<String, &'static str> {
        let mut buffer = [0u8; 512];
        self.read_device_sector(&device.name, start_lba, &mut buffer)?;
        
        // Verificar FAT32
        if &buffer[82..90] == b"FAT32   " && buffer[510] == 0x55 && buffer[511] == 0xAA {
            return Ok(String::from("FAT32"));
        }
        
        // Verificar EclipseFS
        if &buffer[0..9] == b"ECLIPSEFS" {
            return Ok(String::from("EclipseFS"));
        }
        
        // Verificar ext4
        if &buffer[1080..1084] == b"\x53\xEF" {
            return Ok(String::from("ext4"));
        }
        
        // Por defecto, desconocido
        Ok(String::from("Unknown"))
    }

    /// Crear particiones de prueba
    fn create_test_partitions(&mut self, device: &StorageDeviceInfo) {
        // Partición FAT32 de ejemplo
        let fat32_partition = PartitionInfo {
            name: format!("{}1", device.name),
            device_name: device.name.clone(),
            partition_index: 1,
            start_lba: 2048,
            size_lba: 204800, // 100MB
            partition_type: 0x0C, // FAT32
            filesystem_type: String::from("FAT32"),
            bootable: true,
        };
        
        // Partición EclipseFS de ejemplo
        let eclipsefs_partition = PartitionInfo {
            name: format!("{}2", device.name),
            device_name: device.name.clone(),
            partition_index: 2,
            start_lba: 206848,
            size_lba: device.capacity / 512 - 206848,
            partition_type: 0xAF, // EclipseFS
            filesystem_type: String::from("EclipseFS"),
            bootable: false,
        };
        
        self.partitions.push(fat32_partition);
        self.partitions.push(eclipsefs_partition);
        
        serial_write_str(&format!("STORAGE_MANAGER: Creadas 2 particiones en {}\n", device.name));
    }

    /// Verificar si el StorageManager está listo
    pub fn is_ready(&self) -> bool {
        self.is_ready.load(Ordering::SeqCst)
    }

    /// Obtener información de dispositivos
    pub fn get_devices(&self) -> &[StorageDeviceInfo] {
        &self.devices
    }

    /// Obtener información de particiones
    pub fn get_partitions(&self) -> &[PartitionInfo] {
        &self.partitions
    }

    /// Leer sector de un dispositivo
    pub fn read_device_sector(&self, device_name: &str, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Leyendo sector {} de {}\n", sector, device_name));
        
        // Encontrar el dispositivo
        let device = self.devices.iter()
            .find(|d| d.name == device_name)
            .ok_or("Dispositivo no encontrado")?;
        
        // Usar el driver apropiado según el tipo de controlador
        match device.controller_type {
            StorageControllerType::AHCI => {
                if AHCI_ENABLED {
                    self.read_ahci_sector(device, sector, buffer)
                } else {
                    serial_write_str("STORAGE_MANAGER: AHCI deshabilitado, usando ATA fallback\n");
                    self.read_ata_sector_fallback(device, sector, buffer)
                }
            },
            StorageControllerType::IDE => {
                self.read_ide_sector(device, sector, buffer)
            },
            StorageControllerType::ATA => {
                self.read_ata_sector(device, sector, buffer)
            },
            StorageControllerType::NVMe => {
                self.read_nvme_sector(device, sector, buffer)
            },
            StorageControllerType::VirtIO => {
                self.read_virtio_sector(device, sector, buffer)
            },
        }
    }

    /// Leer sector usando driver AHCI con fallback robusto
    fn read_ahci_sector(&self, device: &StorageDeviceInfo, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Usando driver AHCI para {}\n", device.name));
        
        // Intentar driver AHCI primero
        let mut ahci_driver = AhciDriver::new_from_pci(device.vendor_id, device.device_id, 0xFEB80000u64);
        
        if let Err(e) = ahci_driver.initialize() {
            serial_write_str(&format!("STORAGE_MANAGER: Error inicializando AHCI: {}\n", e));
            serial_write_str("STORAGE_MANAGER: Intentando fallback a driver ATA...\n");
            
            // Fallback 1: Intentar con driver ATA
            return self.read_ata_sector_fallback(device, sector, buffer);
        }
        
        // Leer sector con AHCI
        let sector_u32 = if sector > u32::MAX as u64 {
            serial_write_str("STORAGE_MANAGER: Sector demasiado grande, usando sector 0\n");
            0
        } else {
            sector as u32
        };
        
        match ahci_driver.read_sector(sector_u32, buffer) {
            Ok(_) => Ok(()),
            Err(e) => {
                serial_write_str(&format!("STORAGE_MANAGER: Error leyendo sector AHCI: {}\n", e));
                serial_write_str("STORAGE_MANAGER: Intentando fallback a driver ATA...\n");
                
                // Fallback 2: Intentar con driver ATA si AHCI falla al leer
                self.read_ata_sector_fallback(device, sector, buffer)
            }
        }
    }
    
    /// Fallback a driver ATA cuando AHCI falla
    fn read_ata_sector_fallback(&self, device: &StorageDeviceInfo, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Fallback ATA para {}\n", device.name));
        
        // Crear/usar driver ATA cacheado
        let ata_init_result = unsafe {
            if CACHED_ATA.is_none() {
                serial_write_str("STORAGE_MANAGER: Inicializando driver ATA (cache)\n");
                let mut drv = AtaDirectDriver::new_primary();
                if let Err(e) = drv.initialize() {
                    serial_write_str(&format!("STORAGE_MANAGER: Error inicializando ATA fallback: {}\n", e));
                    None
                } else {
                    CACHED_ATA = Some(drv);
                    serial_write_str("STORAGE_MANAGER: Driver ATA cacheado listo\n");
                    CACHED_ATA.as_mut()
                }
            } else {
                CACHED_ATA.as_mut()
            }
        };

        if ata_init_result.is_none() {
            serial_write_str("STORAGE_MANAGER: Error inicializando ATA fallback (cache)\n");
            serial_write_str("STORAGE_MANAGER: Intentando fallback a datos simulados...\n");
            
            // Fallback final: Datos simulados
            return self.read_simulated_sector(device, sector, buffer);
        }
        let ata_driver = unsafe { CACHED_ATA.as_mut().unwrap() };
        
        // Leer sector con ATA
        let sector_u32 = if sector > u32::MAX as u64 {
            serial_write_str("STORAGE_MANAGER: Sector demasiado grande, usando sector 0\n");
            0
        } else {
            sector as u32
        };
        
        match ata_driver.read_sector(sector_u32, buffer) {
                        Ok(_) => {
                serial_write_str("STORAGE_MANAGER: ✅ Fallback ATA exitoso\n");
                            Ok(())
            },
                        Err(e) => {
                serial_write_str(&format!("STORAGE_MANAGER: Error leyendo sector ATA fallback: {}\n", e));
                serial_write_str("STORAGE_MANAGER: Usando datos simulados como último recurso...\n");
                
                // Fallback final: Datos simulados
                self.read_simulated_sector(device, sector, buffer)
            }
        }
    }
    
    /// Datos simulados como último recurso
    fn read_simulated_sector(&self, device: &StorageDeviceInfo, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Usando datos simulados para {} sector {}\n", device.name, sector));
        
        // Limpiar buffer
        buffer.fill(0);
        
        // Simular datos según el sector
        if sector == 0 {
            // MBR
            buffer[510] = 0x55;
            buffer[511] = 0xAA;
            buffer[446] = 0x80; // Bootable
            buffer[450] = 0x0C; // FAT32 partition type
            // LBA start (little endian)
            buffer[454] = 0x00;
            buffer[455] = 0x08;
            buffer[456] = 0x00;
            buffer[457] = 0x00;
            // LBA size (little endian) - 100MB
            buffer[458] = 0x00;
            buffer[459] = 0x90;
            buffer[460] = 0x01;
            buffer[461] = 0x00;
            
            // Segunda partición EclipseFS
            buffer[462] = 0x00; // Not bootable
            buffer[466] = 0x83; // Linux partition type (EclipseFS)
            // LBA start (little endian) - 206848
            buffer[470] = 0x00;
            buffer[471] = 0x28;
            buffer[472] = 0x03;
            buffer[473] = 0x00;
            // LBA size (little endian) - 923MB
            buffer[474] = 0x00;
            buffer[475] = 0x00;
            buffer[476] = 0x1C;
            buffer[477] = 0x00;
        } else if sector == 2048 {
            // FAT32 boot sector
            buffer[0] = 0xEB;
            buffer[1] = 0x58;
            buffer[2] = 0x90;
            buffer[3] = 0x4D;
            buffer[4] = 0x53;
            buffer[5] = 0x44;
            buffer[6] = 0x4F;
            buffer[7] = 0x53;
            buffer[8] = 0x35;
            buffer[9] = 0x2E;
            buffer[10] = 0x30;
            buffer[11] = 0x00;
            // Bytes per sector
            buffer[11] = 0x00;
            buffer[12] = 0x02;
            // Sectors per cluster
            buffer[13] = 0x08;
            // FAT32 signature
            buffer[82] = 0x29;
            buffer[83] = 0x00;
            buffer[84] = 0x00;
            buffer[85] = 0x00;
        } else if sector == 206848 {
            // EclipseFS header
            buffer[0] = 0x45; // 'E'
            buffer[1] = 0x43; // 'C'
            buffer[2] = 0x4C; // 'L'
            buffer[3] = 0x49; // 'I'
            buffer[4] = 0x50; // 'P'
            buffer[5] = 0x53; // 'S'
            buffer[6] = 0x45; // 'E'
            buffer[7] = 0x46; // 'F'
            buffer[8] = 0x53; // 'S'
            // Version 2.0
            buffer[16] = 0x00;
            buffer[17] = 0x00;
            buffer[18] = 0x02;
            buffer[19] = 0x00;
        }
        
                Ok(())
    }

    /// Leer sector usando driver IDE
    fn read_ide_sector(&self, device: &StorageDeviceInfo, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Usando driver IDE para {}\n", device.name));
        // TODO: Implementar driver IDE
        serial_write_str("STORAGE_MANAGER: Driver IDE no implementado, usando datos simulados\n");
        // Simular datos
        buffer.fill(0);
        if sector == 0 {
            buffer[510] = 0x55;
            buffer[511] = 0xAA;
        }
        Ok(())
    }

    /// Leer sector usando driver ATA
    fn read_ata_sector(&self, device: &StorageDeviceInfo, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Usando driver ATA para {}\n", device.name));
        
        // Usar driver ATA cacheado
        let ata_driver = unsafe {
            if CACHED_ATA.is_none() {
                serial_write_str("STORAGE_MANAGER: Inicializando driver ATA (cache)\n");
                let mut drv = AtaDirectDriver::new_primary();
                if let Err(e) = drv.initialize() {
                    serial_write_str(&format!("STORAGE_MANAGER: Error inicializando ATA: {}\n", e));
                    return Err("Error inicializando ATA");
                }
                CACHED_ATA = Some(drv);
            }
            CACHED_ATA.as_mut().unwrap()
        };
        
        // Leer sector
        let sector_u32 = if sector > u32::MAX as u64 {
            serial_write_str("STORAGE_MANAGER: Sector demasiado grande, usando sector 0\n");
            0
        } else {
            sector as u32
        };
        
        ata_driver.read_sector(sector_u32, buffer)
            .map_err(|e| {
                serial_write_str(&format!("STORAGE_MANAGER: Error leyendo sector ATA: {}\n", e));
                "Error leyendo sector ATA"
            })
    }

    /// Leer sector usando driver NVMe
    fn read_nvme_sector(&self, device: &StorageDeviceInfo, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Usando driver NVMe para {}\n", device.name));
        
        // TODO: Implementar driver NVMe
        serial_write_str("STORAGE_MANAGER: Driver NVMe no implementado, usando datos simulados\n");
        
        // Simular datos
        buffer.fill(0);
        if sector == 0 {
            buffer[510] = 0x55;
            buffer[511] = 0xAA;
        }
        
        Ok(())
    }

    /// Leer sector usando driver VirtIO
    fn read_virtio_sector(&self, device: &StorageDeviceInfo, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Usando driver VirtIO para {}\n", device.name));
        
        // TODO: Implementar driver VirtIO
        serial_write_str("STORAGE_MANAGER: Driver VirtIO no implementado, usando datos simulados\n");
        
        // Simular datos
        buffer.fill(0);
        if sector == 0 {
            buffer[510] = 0x55;
            buffer[511] = 0xAA;
        }
        
        Ok(())
    }

    /// Leer sector de una partición
    pub fn read_from_partition(&self, device_name: &str, partition_index: u32, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        // CORRECCIÓN: EclipseFS pasa partition_index = 2 para /dev/sda2, pero necesitamos convertir a índice de array
        // Las particiones se almacenan con partition_index = 1 y 2, pero el array es 0-indexado
        let partition_array_index = (partition_index - 1) as usize;
        
        serial_write_str(&format!("STORAGE_MANAGER: Buscando partición index {} (array index {}) en device {}\n", 
                                 partition_index, partition_array_index, device_name));
        
        if partition_array_index >= self.partitions.len() {
            return Err("Índice de partición fuera de rango");
        }
        
        let partition = &self.partitions[partition_array_index];
        
        // Verificar que el nombre del dispositivo coincida
        if partition.device_name != device_name {
            return Err("Nombre de dispositivo no coincide");
        }
        
        // Calcular sector absoluto
        let absolute_sector = partition.start_lba + sector;
        
        serial_write_str(&format!("STORAGE_MANAGER: Leyendo sector {} (absoluto: {}) de partición {}:{}\n", 
                                 sector, absolute_sector, device_name, partition_index));
        
        // Leer realmente desde el dispositivo usando el sector absoluto
        self.read_device_sector(device_name, absolute_sector, buffer)
    }

    /// Obtener dispositivos candidatos para FAT32
    pub fn get_fat32_candidates(&self) -> Vec<Fat32DeviceInfo> {
        let mut candidates = Vec::new();
        
        for partition in &self.partitions {
            if partition.filesystem_type == "FAT32" {
                let device_info = Fat32DeviceInfo {
                    device_name: partition.device_name.clone(),
                    start_lba: partition.start_lba,
                    size_lba: partition.size_lba,
                    additional_info: Some(format!("partition_index: {}", partition.partition_index)),
                };
                candidates.push(device_info);
            }
        }
        
        candidates
    }

    /// Obtener dispositivos candidatos para EclipseFS
    pub fn get_eclipsefs_candidates(&self) -> Vec<EclipseFSDeviceInfo> {
        let mut candidates = Vec::new();
        
        for partition in &self.partitions {
            if partition.filesystem_type == "EclipseFS" {
                let device_info = EclipseFSDeviceInfo {
                    device_name: partition.device_name.clone(),
                    start_lba: partition.start_lba,
                    size_lba: partition.size_lba,
                    additional_info: Some(format!("partition_index: {}", partition.partition_index)),
                };
                candidates.push(device_info);
            }
        }
        
        candidates
    }

    /// Obtener número de dispositivos (para compatibilidad)
    pub fn device_count(&self) -> usize {
        self.devices.len()
    }

    /// Encontrar el mejor dispositivo de almacenamiento (para compatibilidad)
    pub fn find_best_storage_device(&self) -> Option<usize> {
        // Retornar el primer dispositivo disponible
        if !self.devices.is_empty() {
            Some(0)
                        } else {
            None
        }
    }

    /// Escribir a una partición (para compatibilidad)
    pub fn write_to_partition(&mut self, device_name: &str, partition_index: u32, sector: u64, buffer: &[u8]) -> Result<(), &'static str> {
        // Encontrar la partición
        let partition = self.partitions.iter()
            .find(|p| p.device_name == device_name && p.partition_index == partition_index)
            .ok_or("Partición no encontrada")?;
        
        // Calcular sector absoluto
        let absolute_sector = partition.start_lba + sector;
        
        serial_write_str(&format!("STORAGE_MANAGER: Escribiendo sector {} (absoluto: {}) a partición {}:{}\n", 
                                 sector, absolute_sector, device_name, partition_index));
        
        // TODO: Implementar escritura real a la partición
        Ok(())
    }

    /// Encontrar partición por nombre (para compatibilidad)
    pub fn find_partition_by_name(&self, name: &str) -> Option<&PartitionInfo> {
        self.partitions.iter().find(|p| p.name == name)
    }

    /// Obtener dispositivo por índice (para compatibilidad)
    pub fn get_device(&self, index: usize) -> Option<&StorageDeviceInfo> {
        self.devices.get(index)
    }

    /// Leer sector de un dispositivo con tipo (para compatibilidad)
    pub fn read_device_sector_with_type(&self, device_info: &StorageDeviceInfo, sector: u64, buffer: &mut [u8], sector_type: StorageSectorType) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Leyendo sector {} de {} (tipo: {:?})\n", sector, device_info.name, sector_type));
        
        // Usar el driver apropiado según el tipo de controlador
        match device_info.controller_type {
            StorageControllerType::AHCI => {
                self.read_ahci_sector(device_info, sector, buffer)
            },
            StorageControllerType::IDE => {
                self.read_ide_sector(device_info, sector, buffer)
            },
            StorageControllerType::ATA => {
                self.read_ata_sector(device_info, sector, buffer)
            },
            StorageControllerType::NVMe => {
                self.read_nvme_sector(device_info, sector, buffer)
            },
            StorageControllerType::VirtIO => {
                self.read_virtio_sector(device_info, sector, buffer)
            },
        }
    }

    /// Leer sector de un dispositivo (alias para compatibilidad)
    pub fn read_device_sector_real(&self, device_name: &str, sector: u64, buffer: &mut [u8]) -> Result<(), &'static str> {
        self.read_device_sector(device_name, sector, buffer)
    }

    /// Escribir sector a un dispositivo (para compatibilidad)
    pub fn write_device_sector(&self, device_name: &str, sector: u64, buffer: &[u8]) -> Result<(), &'static str> {
        serial_write_str(&format!("STORAGE_MANAGER: Escribiendo sector {} a {}\n", sector, device_name));
        
        // Encontrar el dispositivo
        let device = self.devices.iter()
            .find(|d| d.name == device_name)
            .ok_or("Dispositivo no encontrado")?;
        
        // TODO: Implementar escritura real
        serial_write_str("STORAGE_MANAGER: Escritura simulada (no implementada)\n");
        Ok(())
    }
}

/// Instancia global del StorageManager
static mut STORAGE_MANAGER: Option<StorageManager> = None;

/// Inicializar el StorageManager global
pub fn initialize_storage_manager() -> Result<(), &'static str> {
    unsafe {
        if STORAGE_MANAGER.is_some() {
            return Err("StorageManager ya está inicializado");
        }

        let mut manager = StorageManager::new();
        manager.initialize()?;
        STORAGE_MANAGER = Some(manager);

    Ok(())
    }
}

/// Alias para compatibilidad
pub fn init_storage_manager() -> Result<(), &'static str> {
    initialize_storage_manager()
}

/// Obtener referencia al StorageManager global
pub fn get_storage_manager() -> Option<&'static StorageManager> {
    unsafe {
        STORAGE_MANAGER.as_ref()
    }
}

/// Verificar si el StorageManager está listo
pub fn is_storage_manager_ready() -> bool {
    unsafe {
        STORAGE_MANAGER.as_ref().map(|m| m.is_ready()).unwrap_or(false)
    }
}